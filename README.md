# Leetcode
###001. Two Sum [Java Solution](https://github.com/ycl11761/Leetcode/blob/master/001_TwoSum.java)         
**Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution.**

###021. Merge Two Sorted Lists [Recursive Solution](https://github.com/ycl11761/Leetcode/blob/master/021_MergeSortedLists.c)   [FindAll-Relink Solution](https://github.com/ycl11761/Leetcode/blob/master/021_MergeSortedLists2.c)      
**Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.**                                      

###023. Merge K Sorted Lists [Merge-Sort Solution](https://github.com/ycl11761/Leetcode/blob/master/023_MergeKSortedLists.c)
**Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.**

###026. Remove Duplicates from Sorted Array [Solution](https://github.com/ycl11761/Leetcode/blob/master/026_RemoveDuplicates.c) 
**Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.**
**Do not allocate extra space for another array, you must do this in place with constant memory.**                         
**For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.**        

###066. Plus One [C Solution](https://github.com/ycl11761/Leetcode/blob/master/066_PlusOne.c)        [Java Solution](https://github.com/ycl11761/Leetcode/blob/master/066_PlusOne.java)
**Given a non-negative number represented as an array of digits, plus one to the number.**                                    **The digits are stored such that the most significant digit is at the head of the list.**                            

###080. Remove Duplicates from Sorted Array II [Solution](https://github.com/ycl11761/Leetcode/blob/master/080_RemoveDuplicatesII.c)
**Follow up for "Remove Duplicates": What if duplicates are allowed at most twice?**
**For example,Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.**                              
*Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.*  

###088. Merge Sorted Array [Solution] (https://github.com/ycl11761/Leetcode/blob/master/088_MergeSortedArrays.c)
**Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.**                              
*Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.*  

###136. Single Number [Solution] (https://github.com/ycl11761/Leetcode/blob/master/136_SingleNumber.c)
**Given an array of integers, every element appears twice except for one. Find that single one.**                   
*Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?*            

###151. Reverse Words in a String [Solution] (https://github.com/ycl11761/Leetcode/blob/master/151_ReverseWords.c)
**Given an input string, reverse the string word by word.**                                                                   **For example, Given s = "the sky is blue", return "blue is sky the".**  
*Note: For C programmers: Try to solve it in-place in O(1) space.*      

###283. Move Zeroes [Solution] (https://github.com/ycl11761/Leetcode/blob/master/283_MoveZeros.c)
**Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.**
**For example, nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].**
*Note:You must do this in-place without making a copy of the array and Minimize the total number of operations.* 

###288. Unique Word Abbreviation [Solution 1] (https://github.com/ycl11761/Leetcode/blob/master/288_ValidWordAbbr.java) [Solution 2] (https://github.com/ycl11761/Leetcode/blob/master/288_ValidWordAbbr2.java)
**An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:**<br>
(a)it                      --> it    (no abbreviation)<br>
(b)d|o|g                   --> d1g<br>
(c)i|nternationalizatio|n  --> i18n<br>
(d)l|ocalizatio|n          --> l10n<br>
**Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.**
**for example, Given dictionary = [ "deer", "door", "cake", "card" ], **
**isUnique("dear") -> false,**  
**isUnique("cart") -> true,**
**isUnique("cane") -> false,**
**isUnique("make") -> true**

###347. Top K Frequent Elements [Solution] (https://github.com/ycl11761/Leetcode/blob/master/347_TopKFrequent.java)
**Given a non-empty array of integers, return the k most frequent elements.**
**For example, Given [1,1,1,2,2,3] and k = 2, return [1,2].**</br>
*Note: (1) you may assume k is always valid, 1 ≤ k ≤ number of unique elements.
(2)Your algorithm's time complexity must be better than O(n log n), where n is the array's size..* 

