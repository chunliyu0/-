# Leetcode
###001. Two Sum [Java Solution](https://github.com/ycl11761/Leetcode/blob/master/001_TwoSum.java)         
**Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution.**

###007. Reverse Integer [Java Solution](https://github.com/ycl11761/Leetcode/blob/master/007_ReverseInteger.c)         
**Reverse digits of an integer.**</br>
**Example1: x = 123, return 321**</br>
**Example2: x = -123, return -321**</br>

###008. String to Integer [Solution](https://github.com/ycl11761/Leetcode/blob/master/008_MyAtoi.c)         
**Implement atoi to convert a string to an integer. </br>**
**Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.**</br>

*Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.*

###021. Merge Two Sorted Lists [Recursive Solution](https://github.com/ycl11761/Leetcode/blob/master/021_MergeSortedLists.c)   [FindAll-Relink Solution](https://github.com/ycl11761/Leetcode/blob/master/021_MergeSortedLists2.c)      
**Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.**                                      

###023. Merge K Sorted Lists [Merge-Sort Solution](https://github.com/ycl11761/Leetcode/blob/master/023_MergeKSortedLists.c)
**Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.**

###026. Remove Duplicates from Sorted Array [Solution](https://github.com/ycl11761/Leetcode/blob/master/026_RemoveDuplicates.c) 
**Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.**
**Do not allocate extra space for another array, you must do this in place with constant memory.**                         
**For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.**        

###041. First Missing Positive [C Solution](https://github.com/ycl11761/Leetcode/blob/master/041_FirstMissingPositive.c) 
**Given an unsorted integer array, find the first missing positive integer.**</br>
**For example, Given [1,2,0] return 3, and [3,4,-1,1] return 2.**</br>
**Your algorithm should run in O(n) time and uses constant space.** 
   
###050. Implement pow(x, n) [C Solution](https://github.com/ycl11761/Leetcode/blob/master/050_Pow.c) 

###066. Plus One [C Solution](https://github.com/ycl11761/Leetcode/blob/master/066_PlusOne.c)        [Java Solution](https://github.com/ycl11761/Leetcode/blob/master/066_PlusOne.java)
**Given a non-negative number represented as an array of digits, plus one to the number.**                                       
**The digits are stored such that the most significant digit is at the head of the list.**   

###069. Sqrt(x) [Solution](https://github.com/ycl11761/Leetcode/blob/master/069_Sqrt.c)       
**Implement int sqrt(int x). Compute and return the square root of x.**                                       

###080. Remove Duplicates from Sorted Array II [Solution](https://github.com/ycl11761/Leetcode/blob/master/080_RemoveDuplicatesII.c)
**Follow up for "Remove Duplicates": What if duplicates are allowed at most twice?**
**For example,Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.**                              
*Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.*  

###082. Remove Duplicates from Sorted List II [Solution](https://github.com/ycl11761/Leetcode/blob/master/082_RemoveDuplicatesII.c)
**Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.**
**For example,**
**Given 1->2->3->3->4->4->5, return 1->2->5.** 
**Given 1->1->1->2->3, return 2->3.**

###088. Merge Sorted Array [Solution] (https://github.com/ycl11761/Leetcode/blob/master/088_MergeSortedArrays.c)
**Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.**                              
*Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.*  

###136. Single Number [Solution] (https://github.com/ycl11761/Leetcode/blob/master/136_SingleNumber.c)
**Given an array of integers, every element appears twice except for one. Find that single one.**                   
*Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?*            

###141. Linked List Cycle. [Solution] (https://github.com/ycl11761/Leetcode/blob/master/141_LinkedListCycle.c)
**Given a linked list, determine if it has a cycle in it.**                                                                   
*Follow up: Can you solve it without using extra space?*

###142. Linked List Cycle II. [Solution] (https://github.com/ycl11761/Leetcode/blob/master/142_LinkedListCycleII.c)
**Given a linked list, return the node where the cycle begins. If there is no cycle, return null**</br>                               *Follow up: Can you solve it without using extra space?*

###151. Reverse Words in a String [Solution] (https://github.com/ycl11761/Leetcode/blob/master/151_ReverseWords.c)
**Given an input string, reverse the string word by word.**</br>                                                                   
**For example, Given s = "the sky is blue", return "blue is sky the".**</br>  
*Note: For C programmers: Try to solve it in-place in O(1) space.*

###160. Intersection of Two Linked Lists [Solution] (https://github.com/ycl11761/Leetcode/blob/master/160_IntersectionNode.c)
**Write a program to find the node at which the intersection of two singly linked lists begins.**</br>                              **For example, the following two linked lists: begin to intersect at node c1.**</br> 
A:          a1 → a2 → c1 → c2 → c3</br>
B:     b1 → b2 → b3 → c1 → c2 → c3</br>

###162. Find Peak Element [Solution] (https://github.com/ycl11761/Leetcode/blob/master/162_FindPeakElement.c)[Solution2] (https://github.com/ycl11761/Leetcode/blob/master/162_FindPeakElement2.c)
**A peak element is an element that is greater than its neighbors.**</br>
**Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.**</br>
**The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.**</br>
**You may imagine that num[-1] = num[n] = -∞.**</br>
**For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.**</br>                

###167. Two Sum II - Input array is sorted [Solution] (https://github.com/ycl11761/Leetcode/blob/master/167_TwoSumII.c)
**Given an array of integers that is already sorted in ascending order, </br>**
**find two numbers such that they add up to a specific target number.**</br>
**The function twoSum should return indices of the two numbers such that they add up to the target,where index1**</br>
**must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.**</br>
**You may assume that each input would have exactly one solution.**</br>
**Input: numbers={2, 7, 11, 15}, target=9; Output: index1=1, index2=2**</br>                                                        **For example, Given s = "the sky is blue", return "blue is sky the".**</br> 
*Note: For C programmers: Try to solve it in-place in O(1) space.* 

###186. Reverse Words in a String II [Solution] (https://github.com/ycl11761/Leetcode/blob/master/186_ReverseWordsII.c)
**Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.**</br>
**The input string does not contain leading or trailing spaces and the words are always separated by a single space.**</br>
**For example, Given s = "the sky is blue", return "blue is sky the". Could you do it in-place without allocating extra space?**</br>
*Note: For C programmers: Try to solve it in-place in O(1) space.*      

###189. Rotate Array [Solution] (https://github.com/ycl11761/Leetcode/blob/master/189_RotateArray.c)
**Rotate an array of n elements to the right by k steps.**</br>
**For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].**
*Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.*</br>
*Try to solve it in-place in O(1) space.*

###190. Reverse Bits [Solution] (https://github.com/ycl11761/Leetcode/blob/master/190_ReverseBits.c)
**Reverse bits of a given 32 bits unsigned integer.**</br>
**For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).**</br>
**Follow up: If this function is called many times, how would you optimize it?**

###191. Number of 1 Bits [Solution] (https://github.com/ycl11761/Leetcode/blob/master/191_NumberOf1Bits.c)
**Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).**</br>
**For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.**

###215. Kth Largest Element in an Array [Solution1] (https://github.com/ycl11761/Leetcode/blob/master/215_FindKthLargest.c)
###[Solution2] (https://github.com/ycl11761/Leetcode/blob/master/215_FindKthLargest2.c)
###[Solution3] (https://github.com/ycl11761/Leetcode/blob/master/215_FindKthLargest3.c)</br>
**Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.**</br>
**For example, Given [3,2,1,5,6,4] and k = 2, return 5.**</br>
*Note: You may assume k is always valid, 1 ≤ k ≤ array's length.*</br>

###266. Palindrome Permutation [Solution] (https://github.com/ycl11761/Leetcode/blob/master/266_PalindromePermutation.c)
**Given a string, determine if a permutation of the string could form a palindrome.**</br>
**For example, "code" -> False, "aab" -> True, "carerac" -> True.**

###283. Move Zeroes [Solution] (https://github.com/ycl11761/Leetcode/blob/master/283_MoveZeros.c)
**Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.**
**For example, nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].**
*Note:You must do this in-place without making a copy of the array and Minimize the total number of operations.* 

###288. Unique Word Abbreviation [Solution 1] (https://github.com/ycl11761/Leetcode/blob/master/288_ValidWordAbbr.java) [Solution 2] (https://github.com/ycl11761/Leetcode/blob/master/288_ValidWordAbbr2.java)
**An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:**<br>
(a)it                      --> it    (no abbreviation)<br>
(b)d|o|g                   --> d1g<br>
(c)i|nternationalizatio|n  --> i18n<br>
(d)l|ocalizatio|n          --> l10n<br>
**Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.**
**for example, Given dictionary = [ "deer", "door", "cake", "card" ], **
**isUnique("dear") -> false,**  
**isUnique("cart") -> true,**
**isUnique("cane") -> false,**
**isUnique("make") -> true**

###326. Power of Three [Solution] (https://github.com/ycl11761/Leetcode/blob/master/326_PowerOfThree.java)
**Given an integer, write a function to determine if it is a power of three.**</br>
**Follow up: Could you do it without using any loop / recursion?**

###347. Top K Frequent Elements [Solution] (https://github.com/ycl11761/Leetcode/blob/master/347_TopKFrequent.java)
**Given a non-empty array of integers, return the k most frequent elements.**
**For example, Given [1,1,1,2,2,3] and k = 2, return [1,2].**</br>
*Note: (1) you may assume k is always valid, 1 ≤ k ≤ number of unique elements.</br>
       (2) Your algorithm's time complexity must be better than O(n log n), where n is the array's size..* 

###342. Power of Four [Solution] (https://github.com/ycl11761/Leetcode/blob/master/342_PowerOfFour.c)
**Given an integer (signed 32 bits), write a function to check whether it is a power of 4.**</br>
**Example: Given num = 16, return true. Given num = 5, return false.**</br>
**Follow up: Could you solve it without loops/recursion?**

###349.  Intersection of Two Arrays [Solution] (https://github.com/ycl11761/Leetcode/blob/master/349_IntersectionOfTwoArrays.c)
**Given two arrays, write a function to compute their intersection.**
**Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].**
*Note: Each element in the result must be unique.The result can be in any order.*

###350.  Intersection of Two Arrays II [Solution] (https://github.com/ycl11761/Leetcode/blob/master/350_IntersectionOfTwoArraysII.c)
**Given two arrays, write a function to compute their intersection.**</br>
**Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].**</br>
*Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order..*</br>
--Follow up:</br>
What if the given array is already sorted? How would you optimize your algorithm?</br>
What if nums1's size is small compared to num2's size? Which algorithm is better?</br>
What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</br>
