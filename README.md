# Leetcode
###001. Two Sum [Java Solution](https://github.com/ycl11761/Leetcode/blob/master/001_TwoSum.java)         
**Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution.**

###002. Add Two Numbers [Solution](https://github.com/ycl11761/Leetcode/blob/master/002_AddTwoNumbers.c)         
**You are given two linked lists representing two non-negative numbers.**</br> 
**The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.**</br>
**Input: (2 -> 4 -> 3) + (5 -> 6 -> 4), Output: 7 -> 0 -> 8**

###007. Reverse Integer [Solution](https://github.com/ycl11761/Leetcode/blob/master/007_ReverseInteger.c)         
**Reverse digits of an integer.**</br>
**Example1: x = 123, return 321**</br>
**Example2: x = -123, return -321**</br>

###008. String to Integer [Solution](https://github.com/ycl11761/Leetcode/blob/master/008_MyAtoi.c)         
**Implement atoi to convert a string to an integer. </br>**
**Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.**</br>

*Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.*

###012. Integer to Roman [Solution](https://github.com/ycl11761/Leetcode/blob/master/012_IntegerToRoman.java)     
**Given an integer, convert it to a roman numeral.**</br>
**Input is guaranteed to be within the range from 1 to 3999. **

###013. Roman to Integer [Solution](https://github.com/ycl11761/Leetcode/blob/master/013_RomanToInteger.c)     
**Given a roman numeral, convert it to an integer.**</br>
**Input is guaranteed to be within the range from 1 to 3999.**

###021. Merge Two Sorted Lists [Recursive Solution](https://github.com/ycl11761/Leetcode/blob/master/021_MergeSortedLists.c)   [FindAll-Relink Solution](https://github.com/ycl11761/Leetcode/blob/master/021_MergeSortedLists2.c)      
**Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.**                                      

###023. Merge K Sorted Lists [Merge-Sort Solution](https://github.com/ycl11761/Leetcode/blob/master/023_MergeKSortedLists.c)
**Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.**

###026. Remove Duplicates from Sorted Array [Solution](https://github.com/ycl11761/Leetcode/blob/master/026_RemoveDuplicates.c) 
**Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.**
**Do not allocate extra space for another array, you must do this in place with constant memory.**                         
**For example, Given input array nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.**        

###028. Implement strStr() [Solution](https://github.com/ycl11761/Leetcode/blob/master/028_strStr().c)
**Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.**

###041. First Missing Positive [C Solution](https://github.com/ycl11761/Leetcode/blob/master/041_FirstMissingPositive.c) 
**Given an unsorted integer array, find the first missing positive integer.**</br>
**For example, Given [1,2,0] return 3, and [3,4,-1,1] return 2.**</br>
**Your algorithm should run in O(n) time and uses constant space.** 
   
###050. Implement pow(x, n) [C Solution](https://github.com/ycl11761/Leetcode/blob/master/050_Pow.c) 

###066. Plus One [C Solution](https://github.com/ycl11761/Leetcode/blob/master/066_PlusOne.c)        [Java Solution](https://github.com/ycl11761/Leetcode/blob/master/066_PlusOne.java)
**Given a non-negative number represented as an array of digits, plus one to the number.**                                       
**The digits are stored such that the most significant digit is at the head of the list.**   

###067. Add Binary [Solution](https://github.com/ycl11761/Leetcode/blob/master/067_AddBinary.c)       
**Given two binary strings, return their sum (also a binary string).**</br>
**For example, a = "11", b = "1", Return "100".**</br>

###069. Sqrt(x) [Solution](https://github.com/ycl11761/Leetcode/blob/master/069_Sqrt.c)       
**Implement int sqrt(int x). Compute and return the square root of x.**                                       

###080. Remove Duplicates from Sorted Array II [Solution](https://github.com/ycl11761/Leetcode/blob/master/080_RemoveDuplicatesII.c)
**Follow up for "Remove Duplicates": What if duplicates are allowed at most twice?**
**For example,Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.**                              
*Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.*  

###082. Remove Duplicates from Sorted List II [Solution](https://github.com/ycl11761/Leetcode/blob/master/082_RemoveDuplicatesII.c)
**Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.**
**For example,**
**Given 1->2->3->3->4->4->5, return 1->2->5.** 
**Given 1->1->1->2->3, return 2->3.**

###088. Merge Sorted Array [Solution] (https://github.com/ycl11761/Leetcode/blob/master/088_MergeSortedArrays.c)
**Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.**                              
*Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.*  

###136. Single Number [Solution] (https://github.com/ycl11761/Leetcode/blob/master/136_SingleNumber.c)
**Given an array of integers, every element appears twice except for one. Find that single one.**                   
*Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?*            

###141. Linked List Cycle. [Solution] (https://github.com/ycl11761/Leetcode/blob/master/141_LinkedListCycle.c)
**Given a linked list, determine if it has a cycle in it.**                                                                   
*Follow up: Can you solve it without using extra space?*

###142. Linked List Cycle II. [Solution] (https://github.com/ycl11761/Leetcode/blob/master/142_LinkedListCycleII.c)
**Given a linked list, return the node where the cycle begins. If there is no cycle, return null**</br>                               *Follow up: Can you solve it without using extra space?*

###150. Evaluate Reverse Polish Notation [Solution] (https://github.com/ycl11761/Leetcode/blob/master/150_EvaluateReversePolishNotation.java)
**Evaluate the value of an arithmetic expression in Reverse Polish Notation.**</br>
**Valid operators are +, -, *, /. Each operand may be an integer or another expression.**</br>
**Some examples:</br>**
**  ["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9**</br>
**  ["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6**</br>

###151. Reverse Words in a String [Solution] (https://github.com/ycl11761/Leetcode/blob/master/151_ReverseWords.c)
**Given an input string, reverse the string word by word.**</br>                                                                   
**For example, Given s = "the sky is blue", return "blue is sky the".**</br>  
*Note: For C programmers: Try to solve it in-place in O(1) space.*

###160. Intersection of Two Linked Lists [Solution] (https://github.com/ycl11761/Leetcode/blob/master/160_IntersectionNode.c)
**Write a program to find the node at which the intersection of two singly linked lists begins.**</br>                              **For example, the following two linked lists: begin to intersect at node c1.**</br> 
A:          a1 → a2 → c1 → c2 → c3</br>
B:     b1 → b2 → b3 → c1 → c2 → c3</br>

###162. Find Peak Element [Solution] (https://github.com/ycl11761/Leetcode/blob/master/162_FindPeakElement.c)[Solution2] (https://github.com/ycl11761/Leetcode/blob/master/162_FindPeakElement2.c)
**A peak element is an element that is greater than its neighbors.**</br>
**Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.**</br>
**The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.**</br>
**You may imagine that num[-1] = num[n] = -∞.**</br>
**For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.**</br>                

###167. Two Sum II - Input array is sorted [Solution] (https://github.com/ycl11761/Leetcode/blob/master/167_TwoSumII.c)
**Given an array of integers that is already sorted in ascending order, </br>**
**find two numbers such that they add up to a specific target number.**</br>
**The function twoSum should return indices of the two numbers such that they add up to the target,where index1**</br>
**must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.**</br>
**You may assume that each input would have exactly one solution.**</br>
**Input: numbers={2, 7, 11, 15}, target=9; Output: index1=1, index2=2**</br>                                                        **For example, Given s = "the sky is blue", return "blue is sky the".**</br> 
*Note: For C programmers: Try to solve it in-place in O(1) space.* 

###168. Excel Sheet Column Number [Solution] (https://github.com/ycl11761/Leetcode/blob/master/168_ExcelSheetColumnTitle.java)
**Given a positive integer, return its corresponding column title as appear in an Excel sheet.**
**For example: 1 -> A, 2 -> B, 3 -> C ... 26 -> Z, 27 -> AA, 28 -> AB**

###171. Excel Sheet Column Number [Solution] (https://github.com/ycl11761/Leetcode/blob/master/171_ExcelSheetColumnNumber.c)
**Given a column title as appear in an Excel sheet, return its corresponding column number.**
**For example: A -> 1, B -> 2, C -> 3 ... Z -> 26, AA -> 27, AB -> 28**</br>

###179. Largest Number [Solution] (https://github.com/ycl11761/Leetcode/blob/master/179_LargestNumber.java)
**Given a list of non negative integers, arrange them such that they form the largest number.**</br>
**For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330.**</br>
*Note: The result may be very large, so you need to return a string instead of an integer.*

###186. Reverse Words in a String II [Solution] (https://github.com/ycl11761/Leetcode/blob/master/186_ReverseWordsII.c)
**Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters.**</br>
**The input string does not contain leading or trailing spaces and the words are always separated by a single space.**</br>
**For example, Given s = "the sky is blue", return "blue is sky the". Could you do it in-place without allocating extra space?**</br>
*Note: For C programmers: Try to solve it in-place in O(1) space.*      

###189. Rotate Array [Solution] (https://github.com/ycl11761/Leetcode/blob/master/189_RotateArray.c)
**Rotate an array of n elements to the right by k steps.**</br>
**For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].**
*Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.*</br>
*Try to solve it in-place in O(1) space.*

###190. Reverse Bits [Solution] (https://github.com/ycl11761/Leetcode/blob/master/190_ReverseBits.c)
**Reverse bits of a given 32 bits unsigned integer.**</br>
**For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).**</br>
**Follow up: If this function is called many times, how would you optimize it?**

###191. Number of 1 Bits [Solution] (https://github.com/ycl11761/Leetcode/blob/master/191_NumberOf1Bits.c)
**Write a function that takes an unsigned integer and returns the number of ’1' bits it has (also known as the Hamming weight).**</br>
**For example, the 32-bit integer ’11' has binary representation 00000000000000000000000000001011, so the function should return 3.**

###215. Kth Largest Element in an Array [Solution1] (https://github.com/ycl11761/Leetcode/blob/master/215_FindKthLargest.c)
###[Solution2] (https://github.com/ycl11761/Leetcode/blob/master/215_FindKthLargest2.c)
###[Solution3] (https://github.com/ycl11761/Leetcode/blob/master/215_FindKthLargest3.c)</br>
**Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.**</br>
**For example, Given [3,2,1,5,6,4] and k = 2, return 5.**</br>
*Note: You may assume k is always valid, 1 ≤ k ≤ array's length.*</br>

###223. Rectangle Area [Solution] (https://github.com/ycl11761/Leetcode/blob/master/223_RectangleArea.c)
**Find the total area covered by two rectilinear rectangles in a 2D plane.**</br>
**Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.**</br>
**Assume that the total area is never beyond the maximum possible value of int.**</br>

###224. Basic Calculator [Solution] (https://github.com/ycl11761/Leetcode/blob/master/224_BasicCalculator.java)
**Implement a basic calculator to evaluate a simple expression string.**</br>
**The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces. You may assume that the given expression is always valid.**</br>
**for example, "1 + 1" = 2, " 2-1 + 2 " = 3, "(1+(4+5+2)-3)+(6+8)" = 23**</br>

###227. Basic Calculator II [Solution] (https://github.com/ycl11761/Leetcode/blob/master/227_BasicCalculatorII.java)
**Implement a basic calculator to evaluate a simple expression string.**</br>
**The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . **</br>
**The integer division should truncate toward zero.**</br>
**You may assume that the given expression is always valid.**</br>
**Some examples: "3+2*2" = 7, " 3/2 " = 1, " 3+5 / 2 " = 5**</br>

###258. Add Digits [Solution] (https://github.com/ycl11761/Leetcode/blob/master/258_AddDigits.c)
**Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.**</br>
**For example: Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.**</br>
**Follow up: Could you do it without any loop/recursion in O(1) runtime?**

###263. Ugly Number [Solution] (https://github.com/ycl11761/Leetcode/blob/master/263_UglyNumber.java)
**Write a program to check whether a given number is an ugly number.**</br>
**Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. **</br>
**For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. **</br>
**Note that 1 is typically treated as an ugly number.**

###266. Palindrome Permutation [Solution] (https://github.com/ycl11761/Leetcode/blob/master/266_PalindromePermutation.c)
**Given a string, determine if a permutation of the string could form a palindrome.**</br>
**For example, "code" -> False, "aab" -> True, "carerac" -> True.**

###283. Move Zeroes [Solution] (https://github.com/ycl11761/Leetcode/blob/master/283_MoveZeros.c)
**Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.**
**For example, nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].**
*Note:You must do this in-place without making a copy of the array and Minimize the total number of operations.* 

###288. Unique Word Abbreviation [Solution 1] (https://github.com/ycl11761/Leetcode/blob/master/288_ValidWordAbbr.java) [Solution 2] (https://github.com/ycl11761/Leetcode/blob/master/288_ValidWordAbbr2.java)
**An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:**<br>
(a)it                      --> it    (no abbreviation)<br>
(b)d|o|g                   --> d1g<br>
(c)i|nternationalizatio|n  --> i18n<br>
(d)l|ocalizatio|n          --> l10n<br>
**Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.**
**for example, Given dictionary = [ "deer", "door", "cake", "card" ], **
**isUnique("dear") -> false,**  
**isUnique("cart") -> true,**
**isUnique("cane") -> false,**
**isUnique("make") -> true**

###326. Power of Three [Solution] (https://github.com/ycl11761/Leetcode/blob/master/326_PowerOfThree.java)
**Given an integer, write a function to determine if it is a power of three.**</br>
**Follow up: Could you do it without using any loop / recursion?**

###338. Counting Bits [Solution] (https://github.com/ycl11761/Leetcode/blob/master/338_CountingBits.c)
**Given a non negative integer number num. **
**For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1's in their binary representation and return them as an array.**
**Example: For num = 5 you should return [0,1,1,2,1,2].**

###347. Top K Frequent Elements [Solution] (https://github.com/ycl11761/Leetcode/blob/master/347_TopKFrequent.java)
**Given a non-empty array of integers, return the k most frequent elements.**
**For example, Given [1,1,1,2,2,3] and k = 2, return [1,2].**</br>
*Note: (1) you may assume k is always valid, 1 ≤ k ≤ number of unique elements.</br>
       (2) Your algorithm's time complexity must be better than O(n log n), where n is the array's size..* 

###342. Power of Four [Solution] (https://github.com/ycl11761/Leetcode/blob/master/342_PowerOfFour.c)
**Given an integer (signed 32 bits), write a function to check whether it is a power of 4.**</br>
**Example: Given num = 16, return true. Given num = 5, return false.**</br>
**Follow up: Could you solve it without loops/recursion?**

###349.  Intersection of Two Arrays [Solution] (https://github.com/ycl11761/Leetcode/blob/master/349_IntersectionOfTwoArrays.c)
**Given two arrays, write a function to compute their intersection.**
**Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].**
*Note: Each element in the result must be unique.The result can be in any order.*

###350.  Intersection of Two Arrays II [Solution] (https://github.com/ycl11761/Leetcode/blob/master/350_IntersectionOfTwoArraysII.c)
**Given two arrays, write a function to compute their intersection.**</br>
**Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].**</br>
*Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order..*</br>
--Follow up:</br>
What if the given array is already sorted? How would you optimize your algorithm?</br>
What if nums1's size is small compared to num2's size? Which algorithm is better?</br>
What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</br>
